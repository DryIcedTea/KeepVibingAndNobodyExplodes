<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/KeepVibingAndNobodyExplodes.csproj">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/KeepVibingAndNobodyExplodes.csproj" />
              <option name="originalContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;  &lt;PropertyGroup&gt;&#10;    &lt;TargetFramework&gt;net35&lt;/TargetFramework&gt;&#10;    &lt;AssemblyName&gt;KeepVibingAndNobodyExplodes&lt;/AssemblyName&gt;&#10;    &lt;Product&gt;My first plugin&lt;/Product&gt;&#10;    &lt;Version&gt;1.0.0&lt;/Version&gt;&#10;    &lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;&#10;    &lt;LangVersion&gt;latest&lt;/LangVersion&gt;&#10;    &lt;RestoreAdditionalProjectSources&gt;&#10;      https://api.nuget.org/v3/index.json;&#10;      https://nuget.bepinex.dev/v3/index.json;&#10;      https://nuget.samboy.dev/v3/index.json&#10;    &lt;/RestoreAdditionalProjectSources&gt;&#10;    &lt;RootNamespace&gt;KeepVibingAndNobodyExplodes&lt;/RootNamespace&gt;&#10;  &lt;/PropertyGroup&gt;&#10;&#10;  &lt;ItemGroup&gt;&#10;    &lt;PackageReference Include=&quot;BepInEx.Analyzers&quot; Version=&quot;1.*&quot; PrivateAssets=&quot;all&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;BepInEx.Core&quot; Version=&quot;5.*&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;BepInEx.PluginInfoProps&quot; Version=&quot;2.*&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;HarmonyX&quot; Version=&quot;2.14.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;LitJson&quot; Version=&quot;0.19.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;UnityEngine.Modules&quot; Version=&quot;2017.4.22&quot; IncludeAssets=&quot;compile&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;WebSocket4Net&quot; Version=&quot;0.15.2&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;  &#10;  &lt;ItemGroup Condition=&quot;'$(TargetFramework.TrimEnd(`0123456789`))' == 'net'&quot;&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.NETFramework.ReferenceAssemblies&quot; Version=&quot;1.0.2&quot; PrivateAssets=&quot;all&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;&lt;/Project&gt;&#10;" />
              <option name="updatedContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;  &lt;PropertyGroup&gt;&#10;    &lt;TargetFramework&gt;net35&lt;/TargetFramework&gt;&#10;    &lt;AssemblyName&gt;KeepVibingAndNobodyExplodes&lt;/AssemblyName&gt;&#10;    &lt;Product&gt;My first plugin&lt;/Product&gt;&#10;    &lt;Version&gt;1.0.0&lt;/Version&gt;&#10;    &lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;&#10;    &lt;LangVersion&gt;latest&lt;/LangVersion&gt;&#10;    &lt;RestoreAdditionalProjectSources&gt;&#10;      https://api.nuget.org/v3/index.json;&#10;      https://nuget.bepinex.dev/v3/index.json;&#10;      https://nuget.samboy.dev/v3/index.json&#10;    &lt;/RestoreAdditionalProjectSources&gt;&#10;    &lt;RootNamespace&gt;KeepVibingAndNobodyExplodes&lt;/RootNamespace&gt;&#10;  &lt;/PropertyGroup&gt;&#10;&#10;  &lt;ItemGroup&gt;&#10;    &lt;PackageReference Include=&quot;BepInEx.Analyzers&quot; Version=&quot;1.*&quot; PrivateAssets=&quot;all&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;BepInEx.Core&quot; Version=&quot;5.*&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;BepInEx.PluginInfoProps&quot; Version=&quot;2.*&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;HarmonyX&quot; Version=&quot;2.14.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;LitJson&quot; Version=&quot;0.19.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;UnityEngine.Modules&quot; Version=&quot;2017.4.22&quot; IncludeAssets=&quot;compile&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;WebSocket4Net&quot; Version=&quot;0.15.2&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;  &#10;  &lt;ItemGroup Condition=&quot;'$(TargetFramework.TrimEnd(`0123456789`))' == 'net'&quot;&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.NETFramework.ReferenceAssemblies&quot; Version=&quot;1.0.2&quot; PrivateAssets=&quot;all&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;&#10;  &lt;ItemGroup&gt;&#10;    &lt;Reference Include=&quot;Assembly-CSharp&quot;&gt;&#10;      &lt;HintPath&gt;Assembly-CSharp.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;  &lt;/ItemGroup&gt;&#10;&lt;/Project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Plugin.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Plugin.cs" />
              <option name="originalContent" value="using BepInEx;&#10;using BepInEx.Logging;&#10;using UnityEngine;&#10;&#10;namespace KeepVibingAndNobodyExplodes;&#10;&#10;[BepInPlugin(MyPluginInfo.PLUGIN_GUID, MyPluginInfo.PLUGIN_NAME, MyPluginInfo.PLUGIN_VERSION)]&#10;public class Plugin : BaseUnityPlugin&#10;{&#10;    internal static new ManualLogSource Logger;&#10;    private ButtplugManager buttplugManager;&#10;    &#10;    private void Awake()&#10;    {&#10;        // Plugin startup logic&#10;        Logger = base.Logger;&#10;        Logger.LogInfo($&quot;Plugin {MyPluginInfo.PLUGIN_GUID} is loaded!&quot;);&#10;        &#10;        // Initialize Buttplug manager&#10;        InitializeButtplug();&#10;    }&#10;    &#10;    private void InitializeButtplug()&#10;    {&#10;        // Create a GameObject to host the ButtplugManager&#10;        var buttplugObject = new GameObject(&quot;ButtplugManager&quot;);&#10;        DontDestroyOnLoad(buttplugObject);&#10;        &#10;        // Add and initialize the ButtplugManager&#10;        buttplugManager = buttplugObject.AddComponent&lt;ButtplugManager&gt;();&#10;        buttplugManager.Initialize(Logger);&#10;        &#10;        // Set up event handlers&#10;        buttplugManager.OnDeviceListUpdated += (sender, args) =&gt;&#10;        {&#10;            Logger.LogInfo($&quot;Devices updated: {args.After.Count} devices connected&quot;);&#10;            buttplugManager.LogDeviceInfo();&#10;        };&#10;        &#10;        Logger.LogInfo(&quot;ButtplugManager initialized. Use 'buttplugManager.Connect()' to connect to Intiface.&quot;);&#10;    }&#10;    &#10;    private void Start()&#10;    {&#10;        // Auto-connect to Intiface server on start (optional)&#10;        if (buttplugManager != null)&#10;        {&#10;            Logger.LogInfo(&quot;Attempting to connect to Intiface server...&quot;);&#10;            buttplugManager.Connect();&#10;        }&#10;    }&#10;    &#10;    public void TestVibration()&#10;    {&#10;        if (buttplugManager != null &amp;&amp; buttplugManager.IsConnected)&#10;        {&#10;            // Test vibration on first available device&#10;            var devices = buttplugManager.Devices;&#10;            if (devices.Count &gt; 0)&#10;            {&#10;                Logger.LogInfo(&quot;Testing vibration for 2 seconds...&quot;);&#10;                buttplugManager.VibrateDevice(devices[0].DeviceName, 0.5f, 2.0f);&#10;            }&#10;            else&#10;            {&#10;                Logger.LogInfo(&quot;No devices available for testing&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Logger.LogInfo(&quot;Not connected to Intiface server&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using BepInEx;&#10;using BepInEx.Logging;&#10;using UnityEngine;&#10;using HarmonyLib;&#10;&#10;namespace KeepVibingAndNobodyExplodes;&#10;&#10;[BepInPlugin(MyPluginInfo.PLUGIN_GUID, MyPluginInfo.PLUGIN_NAME, MyPluginInfo.PLUGIN_VERSION)]&#10;public class Plugin : BaseUnityPlugin&#10;{&#10;    internal static new ManualLogSource Logger;&#10;    private ButtplugManager buttplugManager;&#10;    private static Plugin instance;&#10;    &#10;    // Harmony instance&#10;    private const string harmonyId = &quot;com.yourname.ktane.hapticsmod&quot;;&#10;    private static Harmony harmonyInstance;&#10;    &#10;    private void Awake()&#10;    {&#10;        // Plugin startup logic&#10;        Logger = base.Logger;&#10;        Logger.LogInfo($&quot;Plugin {MyPluginInfo.PLUGIN_GUID} is loaded!&quot;);&#10;        &#10;        // Set instance for static access&#10;        instance = this;&#10;        &#10;        // Initialize Buttplug manager&#10;        InitializeButtplug();&#10;        &#10;        // Apply Harmony patches&#10;        ApplyHarmonyPatches();&#10;    }&#10;    &#10;    private void ApplyHarmonyPatches()&#10;    {&#10;        if (harmonyInstance == null)&#10;        {&#10;            harmonyInstance = new Harmony(harmonyId);&#10;        }&#10;        &#10;        // This will find all classes in your assembly with HarmonyPatch attributes and apply them.&#10;        harmonyInstance.PatchAll();&#10;        Logger.LogInfo(&quot;Harmony patches applied.&quot;);&#10;    }&#10;    &#10;    private void InitializeButtplug()&#10;    {&#10;        // Create a GameObject to host the ButtplugManager&#10;        var buttplugObject = new GameObject(&quot;ButtplugManager&quot;);&#10;        DontDestroyOnLoad(buttplugObject);&#10;        &#10;        // Add and initialize the ButtplugManager&#10;        buttplugManager = buttplugObject.AddComponent&lt;ButtplugManager&gt;();&#10;        buttplugManager.Initialize(Logger);&#10;        &#10;        // Set up event handlers&#10;        buttplugManager.OnDeviceListUpdated += (sender, args) =&gt;&#10;        {&#10;            Logger.LogInfo($&quot;Devices updated: {args.After.Count} devices connected&quot;);&#10;            buttplugManager.LogDeviceInfo();&#10;        };&#10;        &#10;        Logger.LogInfo(&quot;ButtplugManager initialized. Use 'buttplugManager.Connect()' to connect to Intiface.&quot;);&#10;    }&#10;    &#10;    private void Start()&#10;    {&#10;        // Auto-connect to Intiface server on start (optional)&#10;        if (buttplugManager != null)&#10;        {&#10;            Logger.LogInfo(&quot;Attempting to connect to Intiface server...&quot;);&#10;            buttplugManager.Connect();&#10;        }&#10;    }&#10;    &#10;    public void TestVibration()&#10;    {&#10;        if (buttplugManager != null &amp;&amp; buttplugManager.IsConnected)&#10;        {&#10;            // Test vibration on first available device&#10;            var devices = buttplugManager.Devices;&#10;            if (devices.Count &gt; 0)&#10;            {&#10;                Logger.LogInfo(&quot;Testing vibration for 2 seconds...&quot;);&#10;                buttplugManager.VibrateDevice(devices[0].DeviceName, 0.5f, 2.0f);&#10;            }&#10;            else&#10;            {&#10;                Logger.LogInfo(&quot;No devices available for testing&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Logger.LogInfo(&quot;Not connected to Intiface server&quot;);&#10;        }&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Vibrates all connected vibrator devices&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;power&quot;&gt;Vibration power (0.0 to 1.0)&lt;/param&gt;&#10;    /// &lt;param name=&quot;duration&quot;&gt;Duration in seconds&lt;/param&gt;&#10;    public void VibrateAllDevices(float power, float duration)&#10;    {&#10;        if (buttplugManager != null &amp;&amp; buttplugManager.IsConnected)&#10;        {&#10;            var devices = buttplugManager.Devices;&#10;            if (devices.Count &gt; 0)&#10;            {&#10;                Logger.LogInfo($&quot;Vibrating {devices.Count} devices at {power} power for {duration} seconds&quot;);&#10;                foreach (var device in devices)&#10;                {&#10;                    buttplugManager.VibrateDevice(device.DeviceName, power, duration);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Logger.LogInfo(&quot;No devices available for vibration&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Logger.LogInfo(&quot;Not connected to Intiface server&quot;);&#10;        }&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Static access to vibrate devices from Harmony patches&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;power&quot;&gt;Vibration power (0.0 to 1.0)&lt;/param&gt;&#10;    /// &lt;param name=&quot;duration&quot;&gt;Duration in seconds&lt;/param&gt;&#10;    public static void TriggerVibration(float power, float duration)&#10;    {&#10;        instance?.VibrateAllDevices(power, duration);&#10;    }&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// This class contains the patch for the SnippableWire's Interact method.&#10;/// &lt;/summary&gt;&#10;[HarmonyPatch(typeof(SnippableWire), &quot;Interact&quot;)]&#10;public class WireSnipHapticPatch&#10;{&#10;    /// &lt;summary&gt;&#10;    /// This is the Harmony Prefix. It runs *before* the original Interact method.&#10;    /// We use it to save the state of the wire before it's cut.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;__instance&quot;&gt;The instance of the SnippableWire being interacted with.&lt;/param&gt;&#10;    /// &lt;param name=&quot;__state&quot;&gt;A special Harmony parameter to pass data from Prefix to Postfix.&lt;/param&gt;&#10;    [HarmonyPrefix]&#10;    public static void Prefix(SnippableWire __instance, out bool __state)&#10;    {&#10;        // Store the &quot;snipped&quot; status of the wire *before* the Interact method runs.&#10;        // This will be 'false' if the wire is about to be cut.&#10;        __state = __instance.Snipped;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// This is the Harmony Postfix. It runs *after* the original Interact method.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;__instance&quot;&gt;The instance of the SnippableWire that was interacted with.&lt;/param&gt;&#10;    /// &lt;param name=&quot;__state&quot;&gt;The data we saved in the Prefix method.&lt;/param&gt;&#10;    [HarmonyPostfix]&#10;    public static void Postfix(SnippableWire __instance, bool __state)&#10;    {&#10;        // Retrieve the state from before the method ran.&#10;        bool wasSnippedBeforeInteract = __state;&#10;        &#10;        // Get the state *after* the method has run.&#10;        bool isSnippedAfterInteract = __instance.Snipped;&#10;&#10;        // We only want to fire the haptic if the state changed from not-snipped to snipped.&#10;        if (!wasSnippedBeforeInteract &amp;&amp; isSnippedAfterInteract)&#10;        {&#10;            // Vibrate all devices at 0.5 power for 0.6 seconds when wire is cut&#10;            Plugin.TriggerVibration(0.5f, 0.6f);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>